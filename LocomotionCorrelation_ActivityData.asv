%% Locomotion Correlation - Activity Data Analysis
function LocomotionCorrelation_ActivityData(ActivityData, WindowLength, params, Rec, Performance, Behav, conditions, Skip)
% LOCOMOTIONCORRELATION_ACTIVITYDATA - Analyze neural activity around locomotion periods
% across different behavioral conditions. Uses trial-based locomotion analysis.
%
% INPUTS:
%   ActivityData - Structure containing neural activity data for different conditions
%   Behav- 
%   WindowLength - Structure containing window length information
%   params       - Structure containing plotting parameters including colors
%   Rec          - Recording metadata structure
%   Performance  - Performance metrics structure containing trial data
%   conditions   - Cell array of condition names to analyze (e.g., {'Expert', 'Beginner'})
%   Skip         - (optional) Structure containing recording indices to skip for each condition
%
% OUTPUTS:
%   For each position (All, P1, P3):
%   • Figure 1: Pre vs Post dF/F scatter around locomotion events – Wilcoxon signed‑rank (paired)
%   • Figure 2: Pre vs Post dF/F violin plot
%   • Figure 3: Histogram of Post/Pre activity ratios – sign‑rank against median of 1
%   • Figure 4: Pre value vs Change scatter (dF/F) – Spearman ρ with p‑value
%   • Figure 5: Locomotion triggered plots (neural activity time series)
%   • Figure 6: Locomotion vs activity frame-by-frame scatter plot with correlation analysis
%

%% FramRate Info
LocomotionFrameRate = 50; %Hz

threshold = 2.0; % cm/s

%% Input validation
if nargin < 8 || isempty(Skip)
    Skip = struct(); 
end

if nargin < 7 || isempty(conditions)
    conditions = {};
    if isfield(ActivityData, 'Expert'); conditions{end+1} = 'Expert'; end
    if isfield(ActivityData, 'Beginner'); conditions{end+1} = 'Beginner'; end
    if isfield(ActivityData, 'Naive'); conditions{end+1} = 'Naive'; end
    if isfield(ActivityData, 'NoSpout'); conditions{end+1} = 'NoSpout'; end
end

% positions = {'All', 'P1', 'P3'};
positions = {'All'};

fprintf('Processing locomotion correlations for ACTIVITY DATA in conditions: %s\n', strjoin(conditions, ', '));
fprintf('Positions: %s\n', strjoin(positions, ', '));

% Print Skip information if provided
if ~isempty(fieldnames(Skip))
    fprintf('Skip information provided for conditions: %s\n', strjoin(fieldnames(Skip), ', '));
    for skip_field = fieldnames(Skip)'
        fprintf('  %s: skipping recordings %s\n', skip_field{1}, mat2str(Skip.(skip_field{1})));
    end
else
    fprintf('No recordings will be skipped (Skip structure is empty)\n');
end

%% Loop through each position with "Data First, Plots Second" approach
for pos_idx = 1:length(positions)
    position = positions{pos_idx};
    fprintf('\n\n======== PROCESSING POSITION: %s ========\n', position);
    
    %% ==================== PHASE 1: DATA EXTRACTION ====================
    fprintf('\n*** PHASE 1: DATA EXTRACTION ***\n');
    
    % Step 1: Extract locomotion event data
    fprintf('\n--- Step 1: Locomotion Event Data Extraction ---\n');
    Fig1_Data = extractLocomotionEventActivityData(conditions, ActivityData, Behav, Skip, position, Performance, LocomotionFrameRate, threshold);
    
    % Step 2: Calculate activity ratios
    fprintf('\n--- Step 2: Activity Ratio Calculation ---\n');
    Fig3_Data = calculateLocomotionActivityRatios(Fig1_Data);
    
    % Step 3: Calculate activity changes
    fprintf('\n--- Step 3: Activity Change Calculation ---\n');
    Fig4_Data = calculateLocomotionActivityChanges(Fig1_Data);
    
    % Step 4: Extract triggered data for peri-event plots
    fprintf('\n--- Step 4: Locomotion Triggered Data Extraction ---\n');
    Fig5_Data = extractLocomotionTriggeredActivityData(conditions, ActivityData, Behav, Skip, position, Performance, threshold);
    
    % Step 5: Extract frame-by-frame locomotion vs activity data
    fprintf('\n--- Step 5: Frame-by-Frame Locomotion vs Activity Data Extraction ---\n');
    Fig6_Data = extractFrameByFrameActivityData(conditions, ActivityData, Behav, Skip, position, Performance, LocomotionFrameRate, threshold);
    
    % Step 6: Validate data consistency
    fprintf('\n--- Step 6: Data Validation ---\n');
    validateLocomotionActivityDataConsistency(Fig1_Data, Fig3_Data, Fig4_Data);
    
    %% ==================== PHASE 2: PLOT GENERATION ====================
    fprintf('\n*** PHASE 2: PLOT GENERATION ***\n');
    
    % Check if we have any data
    if isempty(Fig1_Data.PreLocomotionActivity)
        warning('No locomotion event data found for position %s', position);
        continue;
    end
    
    fprintf('Data extraction complete for %s:\n', position);
    fprintf('  Total locomotion events: %d\n', length(Fig1_Data.PreLocomotionActivity));
    fprintf('  Conditions: %s\n', strjoin(unique(Fig1_Data.AllConditionLabels), ', '));
    
    %% Print condition breakdown
    unique_conditions = unique(Fig1_Data.AllConditionLabels);
    for i = 1:length(unique_conditions)
        count = sum(strcmp(Fig1_Data.AllConditionLabels, unique_conditions{i}));
        fprintf('  %s: %d events (%.1f%%)\n', unique_conditions{i}, count, 100*count/length(Fig1_Data.AllConditionLabels));
    end

    %% ------------------------- Figure 1: Activity scatter -------------------- %%
    fprintf('\n--- Generating Figure 1: Pre vs Post Activity Scatter ---\n');
    
    scatterColormap = gray;
    scatterMarkerSize = 30;
    
    figure('Color', 'w', 'Name', sprintf('Pre vs Post Locomotion Activity Scatter - %s', position)); 
    hold on;
    dscatter(Fig1_Data.PreLocomotionActivity, Fig1_Data.PostLocomotionActivity, 'MSIZE', scatterMarkerSize);
    colormap(scatterColormap);
    axis square;
    % Set equal axis limits
    allData = [Fig1_Data.PreLocomotionActivity; Fig1_Data.PostLocomotionActivity];
    dataLim = [min(allData), max(allData)];
    xlim(dataLim);
    ylim(dataLim);
    ref = refline(1); 
    ref.LineWidth = 5; 
    ref.Color = 'r';
    
    [pAct, ~, statsAct] = signrank(Fig1_Data.PreLocomotionActivity, Fig1_Data.PostLocomotionActivity);
    ratioAct = mean(Fig1_Data.PreLocomotionActivity ./ Fig1_Data.PostLocomotionActivity, 'omitnan');
    
    ax = gca;
    ax.FontSize = 20;
    xlabel('Pre-Locomotion Activity (dF/F)');
    ylabel('Post-Locomotion Activity (dF/F)');
    
    title({sprintf('Pre vs Post Locomotion Activity - %s', position), sprintf('ratio = %.3f,  p = %.3g', ratioAct, pAct), ...
           sprintf('n = %d events from %d conditions', length(Fig1_Data.PreLocomotionActivity), length(conditions))});
    
    %% ------------------------- Figure 2: Violin plot -------------------- %%
    fprintf('\n--- Generating Figure 2: Pre vs Post Activity Violin Plot ---\n');
    
    figure('Color', 'w', 'Name', sprintf('Pre vs Post Locomotion Activity Violin Plot - %s', position));
    axesFont = 24;
    daviolinplot({[Fig1_Data.PreLocomotionActivity, Fig1_Data.PostLocomotionActivity]}, ...
                 'violin', 'full', 'groups', ones(numel(Fig1_Data.PreLocomotionActivity), 1), ...
                 'colors', params.colour(13, :), 'box', 3, 'boxcolor', 'w', ...
                 'linkline', 0, 'withinlines', 0, ...
                 'xtlabels', {"Before Locomotion Event", "After Locomotion Event"});
    set(gca, 'FontSize', axesFont);
    ylabel('Activity (dF/F)');
    title(gca, sprintf('Locomotion Activity %s: p = %.3g (n = %d)', position, pAct, length(Fig1_Data.PreLocomotionActivity)));
    
    %% ------------------------- Figure 3: Ratio Histogram --------------- %%
    fprintf('\n--- Generating Figure 3: Post/Pre Activity Ratio Histogram ---\n');
    
    figure('Color', 'w', 'Name', sprintf('Post/Pre Locomotion Activity Ratio Histogram - %s', position));
    
    histogram(Fig3_Data.ActivityRatio, 'Normalization', 'probability', ...
              'BinMethod', 'sturges', 'FaceColor', params.colour(7, :), ...
              'EdgeColor', 'none', 'FaceAlpha', 0.7);
    [pRatioAct] = signrank(Fig3_Data.ActivityRatio - 1);
    ax = gca;
    ax.FontSize = axesFont;
    ax.Box = 'on';
    ax.XLabel.String = 'Post / Pre Activity';
    ax.YLabel.String = 'Probability';
    
    title({sprintf('Locomotion Activity Ratio - %s', position), sprintf('p = %.3g', pRatioAct), sprintf('n = %d', length(Fig3_Data.ActivityRatio))});
    
    %% ------------------------- Figure 4: Change vs Pre ------------------ %%
    fprintf('\n--- Generating Figure 4: Activity Change vs Pre-Event Values ---\n');
    
    figure('Color', 'w', 'Name', sprintf('Locomotion Activity Change vs Pre-Event Values - %s', position));
    
    dscatter(Fig1_Data.PreLocomotionActivity, Fig4_Data.ActivityChange, 'MSIZE', scatterMarkerSize);
    colormap(scatterColormap);
    lsline;
    axis square; 
    grid on;
    [rhoAct, pRhoAct] = corr(Fig1_Data.PreLocomotionActivity, Fig4_Data.ActivityChange, ...
                             'Type', 'Spearman', 'Rows', 'complete');
    ax = gca;
    ax.FontSize = axesFont;
    ax.XLabel.String = 'Pre Locomotion Activity (dF/F)';
    ax.YLabel.String = '\Delta Activity (Post - Pre)';
    
    title({sprintf('Locomotion Activity Change vs Pre - %s', position), sprintf('rho = %.2f,  p = %.3g', rhoAct, pRhoAct), ...
           sprintf('n = %d', length(Fig1_Data.PreLocomotionActivity))});
    
    %% ------------------------- Figure 5: Triggered Plots --------------- %%
    fprintf('\n--- Generating Figure 5: Locomotion Triggered Plot ---\n');
    
    if ~isempty(Fig5_Data.TriggeredLocomotion) && ~isempty(Fig5_Data.TriggeredActivity)
        
        % Create subplot figure for triggered data
        figure('Color', 'w', 'Name', sprintf('Locomotion-Triggered Plot - %s', position));

        timeVector = Fig5_Data.TimeVector;
      
        % Triggered Neural Activity
        meanActivity = nanmean(Fig5_Data.TriggeredActivity, 1);
        semActivity = nanstd(Fig5_Data.TriggeredActivity, [], 1) ./ sqrt(sum(~isnan(Fig5_Data.TriggeredActivity), 1));
        
        plot(timeVector, meanActivity, 'LineWidth', 3, 'Color', params.colour(7,:));
        hold on;
        fill([timeVector, fliplr(timeVector)], [meanActivity + semActivity, fliplr(meanActivity - semActivity)], ...
             params.colour(7,:), 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        xline(0, '--k', 'LineWidth', 2);
        xlabel('Time from Locomotion Event (s)');
        ylabel('Neural Activity (dF/F)');
        title(sprintf('Neural Activity Triggered by Locomotion Events - %s (n=%d events)', position, size(Fig5_Data.TriggeredLocomotion,1)));
        grid on;
        ax = gca; ax.FontSize = 16;
        
        fprintf('Generated locomotion triggered plots with %d events\n', size(Fig5_Data.TriggeredLocomotion,1));
    else
        fprintf('No triggered data available for plotting\n');
    end
    
    %% ------------------------- Figure 6: Locomotion vs Activity Scatter ------ %%
    fprintf('\n--- Generating Figure 6: Locomotion vs Activity Scatter Plot ---\n');
    
    if ~isempty(Fig6_Data.AllLocomotionMagnitudes) && ~isempty(Fig6_Data.AllActivityValues)
        
        % Validate data before plotting
        validLocomotionIdx = ~isnan(Fig6_Data.AllLocomotionMagnitudes) & ~isinf(Fig6_Data.AllLocomotionMagnitudes) & (Fig6_Data.AllLocomotionMagnitudes >= 0);
        validActivityIdx = ~isnan(Fig6_Data.AllActivityValues) & ~isinf(Fig6_Data.AllActivityValues);
        validIdx = validLocomotionIdx & validActivityIdx;
        
        if sum(validIdx) > 10
            figure('Color', 'w', 'Name', sprintf('Locomotion vs Activity Scatter - %s', position));
            
            dscatter(Fig6_Data.AllLocomotionMagnitudes(validIdx), Fig6_Data.AllActivityValues(validIdx));
            colormap(scatterColormap);
            
            % Calculate correlation
            [rho, pval] = corr(Fig6_Data.AllLocomotionMagnitudes(validIdx), Fig6_Data.AllActivityValues(validIdx), 'Type', 'Spearman');
            
            % Add trend line
            hold on;
            lsline;
            
            ax = gca;
            ax.FontSize = 16;
            xlabel('Locomotion Speed (cm/s)');
            ylabel('Neural Activity (dF/F)');
            title({sprintf('Locomotion vs Neural Activity - %s', position), ...
                   sprintf('Spearman rho = %.3f, p = %.3g', rho, pval), ...
                   sprintf('n = %d frames from %d conditions', sum(validIdx), length(conditions))});
            grid on;
            
            fprintf('Generated locomotion vs activity scatter with %d valid data points\n', sum(validIdx));
            fprintf('Spearman correlation: rho = %.3f, p = %.3g\n', rho, pval);
        else
            fprintf('Insufficient valid data points for correlation analysis (%d valid points)\n', sum(validIdx));
            if sum(~validLocomotionIdx) > 0
                fprintf('  Invalid locomotion data: %d NaN/inf/negative values\n', sum(~validLocomotionIdx));
            end
            if sum(~validActivityIdx) > 0
                fprintf('  Invalid activity data: %d NaN/inf values\n', sum(~validActivityIdx));
            end
        end
    else
        fprintf('No frame-by-frame data available for plotting\n');
    end
    
    %% Summary output for this position
    fprintf('\nLocomotionCorrelation_ActivityData completed for position %s!\n', position);
    fprintf('Processed %d conditions: %s\n', length(conditions), strjoin(conditions, ', '));
    fprintf('Total locomotion events analyzed: %d\n', length(Fig1_Data.PreLocomotionActivity));

end

fprintf('\n\n======== ALL POSITIONS COMPLETED ========\n');
fprintf('Analyzed positions: %s\n', strjoin(positions, ', '));

% Summary of skip information
if ~isempty(fieldnames(Skip))
    fprintf('\nSummary of skipped recordings:\n');
    for skip_field = fieldnames(Skip)'
        fprintf('  %s: %d recording(s) skipped (%s)\n', skip_field{1}, length(Skip.(skip_field{1})), mat2str(Skip.(skip_field{1})));
    end
else
    fprintf('No recordings were skipped in this analysis.\n');
end

end

%% ======================== HELPER FUNCTIONS ========================

function [Fig1_Data] = extractLocomotionEventActivityData(conditions, ActivityData, Behav, Skip, position, Performance, LocomotionFrameRate, threshold)
    % EXTRACTLOCOMOTIONEVENTACTIVITYDATA - Extract locomotion event data for activity analysis
    
    fprintf('=== Extracting Locomotion Event Activity Data for %s ===\n', position);
    
    % Initialize output structure
    Fig1_Data = struct();
    Fig1_Data.PreLocomotionActivity = [];
    Fig1_Data.PostLocomotionActivity = [];
    Fig1_Data.AllConditionLabels = {};
    
    % Process each condition
    for c_idx = 1:length(conditions)
        condName = conditions{c_idx};
        fprintf('Processing locomotion event activity data for condition: %s\n', condName);
        
        % Get recordings to skip for this condition
        recordingsToSkip = [];
        if isfield(Skip, condName); recordingsToSkip = Skip.(condName); end
        if ~isempty(recordingsToSkip)
            fprintf('  Skipping recordings %s for %s\n', mat2str(recordingsToSkip), condName);
        end
        
        % Check if condition exists in all required structures
        if ~isfield(ActivityData, condName) || ~isfield(Behav, condName)
            warning('Condition %s not found in one or more required data structures', condName);
            continue;
        end
        
        % Get condition data
        condActivityData = ActivityData.(condName);
        condLocomotionData = Behav.(condName);
        
        locomotion_event_count_this_condition = 0;
        
        % Handle different data structures for different conditions
        if strcmp(condName, 'Expert') || strcmp(condName, 'Beginner')
            % Expert/Beginner: cell array format for locomotion
                for i = 1:min(length(condLocomotionData), length(condActivityData))
                    if ismember(i, recordingsToSkip) || isempty(condLocomotionData(i).RunForward); continue; end
                    
                         % Get position-specific trials if Performance data is available
                           activityData = condActivityData(i).all; 
                         validTrials = [];
                            if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                               length(Performance.(condName)) >= i && ~strcmp(position, 'All')
                                
                                % Get position-specific trials
                                if strcmp(position, 'P1')
                                    hitField = 'hitP1'; missField = 'missP1';
                                elseif strcmp(position, 'P3')
                                    hitField = 'hitP3'; missField = 'missP3';
                                else
                                    hitField = 'hit'; missField = 'miss';
                                end
                                
                                if isfield(Performance.(condName)(i), hitField) && isfield(Performance.(condName)(i), missField)
                                    hitTrials = Performance.(condName)(i).(hitField);
                                    missTrials = Performance.(condName)(i).(missField);
                                    validTrials = [hitTrials, missTrials];
                                else
                                    validTrials = 1:size(activityData, 3);
                                end
                            else
                                % Use all trials for 'All' position or when Performance data not available
                                validTrials = 1:size(activityData, 3);
                            end
                            
                            fprintf('    Valid trials for this recording: %d\n', length(validTrials));


                    for t = validTrials
                        if   isfield(condActivityData(i), 'all')
                            locomotionTrace = condLocomotionData(i).RunForward(t,:)' * LocomotionFrameRate;
                            activityData = condActivityData(i).all; % [neurons x frames x trials] - keep as 3D
                            
                            fprintf('  Processing recording %d, trial %d...\n', i, t);
                            
                            % Check if trial exists in activity data
                            if t > size(activityData, 3)
                                fprintf('    Trial %d exceeds activity data dimensions (%d), skipping...\n', t, size(activityData, 3));
                                continue;
                            end
                            
                            
                            % Find high movement periods (locomotion events)
                            high_movement = locomotionTrace > threshold;
                            onsets = find(high_movement == 1);
                            
                            % Process locomotion events
                            for onset_idx = 1:length(onsets)
                                onset_frame = onsets(onset_idx);
                                neural_frame = round(onset_frame * size(activityData, 2) / length(locomotionTrace));
                                
                                if neural_frame > 5 && neural_frame < (size(activityData, 2) - 5)
                                            preActivity = mean(mean(activityData(:, neural_frame-2:neural_frame-1, t), 2), 1);
                                            postActivity = mean(mean(activityData(:, neural_frame+1:neural_frame+2, t), 2), 1);
                                            
                                            Fig1_Data.PreLocomotionActivity = [Fig1_Data.PreLocomotionActivity; preActivity];
                                            Fig1_Data.PostLocomotionActivity = [Fig1_Data.PostLocomotionActivity; postActivity];
                                            Fig1_Data.AllConditionLabels{end+1} = condName;
                                            locomotion_event_count_this_condition = locomotion_event_count_this_condition + 1;
                                        
                                    
                                end
                            end
                        end
                    end
                end
            
            
        else
            % Naive/NoSpout: different structure 
            for a = 1:size(condLocomotionData, 2)
                if ismember(a, recordingsToSkip); continue; end
                
                if isfield(condLocomotionData(a), 'Forward_mm') && ...
                   a <= length(condActivityData) && isfield(condActivityData(a), 'all')
                    locomotionTrace = condLocomotionData(a).Forward_mm;
                    activityData = condActivityData(a).all; % [neurons x frames x trials]
                    
                    fprintf('  Processing recording %d...\n', a);
                    
                    % Trial segmentation
                    TrialLength = floor(length(locomotionTrace) / 150);
                    if TrialLength > 0
                        TrialMovement = 1:TrialLength:length(locomotionTrace);
                        
                        % Get position-specific trials
                        validTrialSegments = [];
                        if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                           length(Performance.(condName)) >= a && ~strcmp(position, 'All')
                            
                            if strcmp(position, 'P1')
                                hitField = 'hitP1'; missField = 'missP1';
                            elseif strcmp(position, 'P3')
                                hitField = 'hitP3'; missField = 'missP3';
                            else
                                hitField = 'hit'; missField = 'miss';
                            end
                            
                            if isfield(Performance.(condName)(a), hitField) && isfield(Performance.(condName)(a), missField)
                                hitTrials = Performance.(condName)(a).(hitField);
                                missTrials = Performance.(condName)(a).(missField);
                                validTrialSegments = [hitTrials, missTrials];
                            else
                                validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                            end
                        else
                            % Use all trial segments for 'All' position or when Performance data not available
                            validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                        end
                        
                        % Process trial segments
                        for t = validTrialSegments
                            
                            trial_start = TrialMovement(t);
                            trial_end = TrialMovement(t+1) - 1;
                            trial_locomotion = locomotionTrace(trial_start:trial_end) * TrialLength / 12;
                            
                            high_movement = trial_locomotion > threshold;
                            onsets = find(diff([0; high_movement]) == 1);
                            
                            for onset_idx = 1:length(onsets)
                                onset_frame = onsets(onset_idx);
                                neural_frame = round(onset_frame * size(activityData, 2) / length(trial_locomotion));
                                
                                if neural_frame > 5 && neural_frame < (size(activityData, 2) - 5)
                                    preActivity = mean(mean(activityData(:, neural_frame-2:neural_frame-1, t), 2), 1);
                                    postActivity = mean(mean(activityData(:, neural_frame+1:neural_frame+2, t), 2), 1);
                                    
                                    Fig1_Data.PreLocomotionActivity = [Fig1_Data.PreLocomotionActivity; preActivity];
                                    Fig1_Data.PostLocomotionActivity = [Fig1_Data.PostLocomotionActivity; postActivity];
                                    Fig1_Data.AllConditionLabels{end+1} = condName;
                                    locomotion_event_count_this_condition = locomotion_event_count_this_condition + 1;
                                end
                            end
                        end
                    end
                end
            end
        end
        
        fprintf('  Added %d locomotion events for %s\n', locomotion_event_count_this_condition, condName);
    end
    
    fprintf('  Total locomotion events extracted: %d\n', length(Fig1_Data.PreLocomotionActivity));
end

function [Fig3_Data] = calculateLocomotionActivityRatios(Fig1_Data)
    % CALCULATELOCOMOTIONACTIVITYRATIOS - Calculate Post/Pre ratios for Figure 3
    
    fprintf('=== Calculating Activity Ratios ===\n');
    
    Fig3_Data = struct();
    
    if ~isempty(Fig1_Data.PreLocomotionActivity)
        Fig3_Data.ActivityRatio = Fig1_Data.PostLocomotionActivity ./ Fig1_Data.PreLocomotionActivity;
        fprintf('  Activity ratios calculated: %d\n', length(Fig3_Data.ActivityRatio));
    else
        Fig3_Data.ActivityRatio = [];
        fprintf('  No data available for ratio calculation\n');
    end
end

function [Fig4_Data] = calculateLocomotionActivityChanges(Fig1_Data)
    % CALCULATELOCOMOTIONACTIVITYCHANGES - Calculate Post-Pre changes for Figure 4
    
    fprintf('=== Calculating Activity Changes ===\n');
    
    Fig4_Data = struct();
    
    if ~isempty(Fig1_Data.PreLocomotionActivity)
        Fig4_Data.ActivityChange = Fig1_Data.PostLocomotionActivity - Fig1_Data.PreLocomotionActivity;
        fprintf('  Activity changes calculated: %d\n', length(Fig4_Data.ActivityChange));
    else
        Fig4_Data.ActivityChange = [];
        fprintf('  No data available for change calculation\n');
    end
end

function [Fig5_Data] = extractLocomotionTriggeredActivityData(conditions, ActivityData, Behav, Skip, position, Performance, threshold)
    % EXTRACTLOCOMOTIONTRIGGEREDACTIVITYDATA - Extract locomotion-triggered time series data for peri-event plots
    
    fprintf('=== Extracting Locomotion Triggered Time Series Activity Data for %s ===\n', position);
    
    % Calculate sampling rates for both data types
    locomotionSamplingRate = size(Behav.Expert(2).RunForward,2)/18.5; % Hz 
    activitySamplingRate = size(ActivityData.Expert(1).all,2)/18.5; % Hz 
    
    % Parameters for triggered analysis 
    preWindowSec = 2;   % 2 seconds before event
    postWindowSec = 4;  % 4 seconds after event
    totalWindowSec = preWindowSec + postWindowSec;
    
    locomotionPreWindowFrames = round(preWindowSec * locomotionSamplingRate);
    locomotionPostWindowFrames = round(postWindowSec * locomotionSamplingRate);
    activityPreWindowFrames = round(preWindowSec * activitySamplingRate);
    activityPostWindowFrames = round(postWindowSec * activitySamplingRate);
    
    % Use activity sampling rate for the time vector (since that's what we'll plot)
    totalActivityFrames = activityPreWindowFrames + activityPostWindowFrames + 1;
    
    % Initialize output structure
    Fig5_Data = struct();
    Fig5_Data.TriggeredLocomotion = [];
    Fig5_Data.TriggeredActivity = [];
    Fig5_Data.TimeVector = linspace(-preWindowSec, postWindowSec, totalActivityFrames);
    
    fprintf('Locomotion sampling rate: %.1f Hz (pre: %d, post: %d frames)\n', locomotionSamplingRate, locomotionPreWindowFrames, locomotionPostWindowFrames);
    fprintf('Activity sampling rate: %.1f Hz (pre: %d, post: %d frames)\n', activitySamplingRate, activityPreWindowFrames, activityPostWindowFrames);
    fprintf('Window: -%.1f to +%.1f seconds\n', preWindowSec, postWindowSec);
    fprintf('Total activity frames per event: %d\n', totalActivityFrames);
    
    % Process each condition
    for c_idx = 1:length(conditions)
        condName = conditions{c_idx};
        fprintf('Processing triggered activity data for condition: %s\n', condName);
        
        % Get recordings to skip for this condition
        recordingsToSkip = [];
        if isfield(Skip, condName); recordingsToSkip = Skip.(condName); end
        if ~isempty(recordingsToSkip)
            fprintf('  Skipping recordings %s for %s\n', mat2str(recordingsToSkip), condName);
        end
        
        % Check if condition exists in all required structures
        if ~isfield(ActivityData, condName) || ~isfield(Behav, condName)
            warning('Condition %s not found in one or more required data structures', condName);
            continue;
        end
        
        % Get condition data
        condActivityData = ActivityData.(condName);
        condLocomotionData = Behav.(condName);
        
        triggered_event_count = 0;
        
        % Handle different data structures for different conditions
        if strcmp(condName, 'Expert') || strcmp(condName, 'Beginner')
            % Expert/Beginner: use the same structure as the working extraction function
            for i = 1:min(length(condLocomotionData), length(condActivityData))
                if ismember(i, recordingsToSkip) || isempty(condLocomotionData(i).RunForward); continue; end
                
                % Get position-specific trials if Performance data is available
                activityData = condActivityData(i).all; 
                validTrials = [];
                if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                   length(Performance.(condName)) >= i && ~strcmp(position, 'All')
                    
                    % Get position-specific trials
                    if strcmp(position, 'P1')
                        hitField = 'hitP1'; missField = 'missP1';
                    elseif strcmp(position, 'P3')
                        hitField = 'hitP3'; missField = 'missP3';
                    else
                        hitField = 'hit'; missField = 'miss';
                    end
                    
                    if isfield(Performance.(condName)(i), hitField) && isfield(Performance.(condName)(i), missField)
                        hitTrials = Performance.(condName)(i).(hitField);
                        missTrials = Performance.(condName)(i).(missField);
                        validTrials = [hitTrials, missTrials];
                    else
                        validTrials = 1:size(activityData, 3);
                    end
                else
                    % Use all trials for 'All' position or when Performance data not available
                    validTrials = 1:size(activityData, 3);
                end

                for t = validTrials
                    if isfield(condActivityData(i), 'all') && t <= size(condLocomotionData(i).RunForward, 1)
                        locomotionTrace = condLocomotionData(i).RunForward(t,:)';
                        
                        % Check if trial exists in activity data
                        if t > size(activityData, 3)
                            fprintf('    Trial %d exceeds activity data dimensions (%d), skipping...\n', t, size(activityData, 3));
                            continue;
                        end
                        
                        % Find high movement periods (locomotion events)
                        high_movement = locomotionTrace > threshold;
                        onsets = find(diff([0; high_movement]) == 1);
                        
                        % Process locomotion events
                        for onset_idx = 1:min(10, length(onsets))
                            onset_frame = onsets(onset_idx);
                            neural_frame = round(onset_frame * size(activityData, 2) / length(locomotionTrace));
                            
                            if neural_frame > activityPreWindowFrames && neural_frame <= (size(activityData, 2) - activityPostWindowFrames)
                                % Extract locomotion data with padding if necessary
                                locStart = onset_frame - locomotionPreWindowFrames;
                                locEnd = onset_frame + locomotionPostWindowFrames;
                                
                                if locStart < 1 || locEnd > length(locomotionTrace)
                                    triggeredLocomotion = nan(1, locomotionPreWindowFrames + locomotionPostWindowFrames + 1);
                                    validStart = max(1, locStart);
                                    validEnd = min(length(locomotionTrace), locEnd);
                                    offsetStart = validStart - locStart + 1;
                                    offsetEnd = offsetStart + (validEnd - validStart);
                                    triggeredLocomotion(offsetStart:offsetEnd) = locomotionTrace(validStart:validEnd);
                                else
                                    triggeredLocomotion = locomotionTrace(locStart:locEnd);
                                end
                                
                                % Extract activity data
                                actStart = neural_frame - activityPreWindowFrames;
                                actEnd = neural_frame + activityPostWindowFrames;
                                triggeredActivity = mean(activityData(:, actStart:actEnd, t), 1);
                                
                                % Resample locomotion data to match activity sampling rate
                                if length(triggeredLocomotion) ~= totalActivityFrames
                                    % Check if we have enough points for interpolation
                                    if length(triggeredLocomotion) < 2
                                        fprintf('    Warning: Insufficient locomotion data points (%d) for interpolation, skipping event\n', length(triggeredLocomotion));
                                        continue;
                                    end
                                    
                                    locomotionTimeVector = linspace(-preWindowSec, postWindowSec, length(triggeredLocomotion));
                                    activityTimeVector = Fig5_Data.TimeVector;
                                    triggeredLocomotion = interp1(locomotionTimeVector, triggeredLocomotion, activityTimeVector, 'linear', 'extrap');
                                end
                                
                                % Add to collection
                                Fig5_Data.TriggeredLocomotion = [Fig5_Data.TriggeredLocomotion; triggeredLocomotion];
                                Fig5_Data.TriggeredActivity = [Fig5_Data.TriggeredActivity; triggeredActivity];
                                triggered_event_count = triggered_event_count + 1;
                            end
                        end
                    end
                end
            end
            
        else
            % Naive/NoSpout: different structure 
            for a = 1:size(condLocomotionData, 2)
                if ismember(a, recordingsToSkip); continue; end
                
                if isfield(condLocomotionData(a), 'Forward_mm') && ...
                   a <= length(condActivityData) && isfield(condActivityData(a), 'all')
                    locomotionTrace = condLocomotionData(a).Forward_mm;
                    activityData = condActivityData(a).all; % [neurons x frames x trials]
                    
                    % Trial segmentation
                    TrialLength = floor(length(locomotionTrace) / 150);
                    if TrialLength > 0
                        TrialMovement = 1:TrialLength:length(locomotionTrace);
                        
                        % Get position-specific trials
                        validTrialSegments = [];
                        if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                           length(Performance.(condName)) >= a && ~strcmp(position, 'All')
                            
                            if strcmp(position, 'P1')
                                hitField = 'hitP1'; missField = 'missP1';
                            elseif strcmp(position, 'P3')
                                hitField = 'hitP3'; missField = 'missP3';
                            else
                                hitField = 'hit'; missField = 'miss';
                            end
                            
                            if isfield(Performance.(condName)(a), hitField) && isfield(Performance.(condName)(a), missField)
                                hitTrials = Performance.(condName)(a).(hitField);
                                missTrials = Performance.(condName)(a).(missField);
                                validTrialSegments = [hitTrials, missTrials];
                            else
                                validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                            end
                        else
                            validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                        end
                        
                        % Process trial segments
                        for t = validTrialSegments
                            
                            trial_start = TrialMovement(t);
                            trial_end = TrialMovement(t+1) - 1;
                            trial_locomotion = locomotionTrace(trial_start:trial_end) * TrialLength / 12;
                            
                            high_movement = trial_locomotion > threshold;
                            onsets = find(diff([0; high_movement]) == 1);
                            
                            for onset_idx = 1:min(5, length(onsets))
                                onset_frame = onsets(onset_idx);
                                neural_frame = round(onset_frame * size(activityData, 2) / length(trial_locomotion));
                                
                                if neural_frame > activityPreWindowFrames && neural_frame <= (size(activityData, 2) - activityPostWindowFrames)
                                    % Extract locomotion data with padding if necessary
                                    locStart = onset_frame - locomotionPreWindowFrames;
                                    locEnd = onset_frame + locomotionPostWindowFrames;
                                    
                                    if locStart < 1 || locEnd > length(trial_locomotion)
                                        triggeredLocomotion = nan(1, locomotionPreWindowFrames + locomotionPostWindowFrames + 1);
                                        validStart = max(1, locStart);
                                        validEnd = min(length(trial_locomotion), locEnd);
                                        offsetStart = validStart - locStart + 1;
                                        offsetEnd = offsetStart + (validEnd - validStart);
                                        triggeredLocomotion(offsetStart:offsetEnd) = trial_locomotion(validStart:validEnd);
                                    else
                                        triggeredLocomotion = trial_locomotion(locStart:locEnd);
                                    end
                                    
                                    % Extract activity data
                                    actStart = neural_frame - activityPreWindowFrames;
                                    actEnd = neural_frame + activityPostWindowFrames;
                                    triggeredActivity = mean(activityData(:, actStart:actEnd, t), 1);
                                    
                                    % Resample locomotion data to match activity sampling rate
                                    if length(triggeredLocomotion) ~= totalActivityFrames
                                        % Check if we have enough points for interpolation
                                        if length(triggeredLocomotion) < 2
                                            fprintf('    Warning: Insufficient locomotion data points (%d) for interpolation, skipping event\n', length(triggeredLocomotion));
                                            continue;
                                        end
                                        
                                        locomotionTimeVector = linspace(-preWindowSec, postWindowSec, length(triggeredLocomotion));
                                        activityTimeVector = Fig5_Data.TimeVector;
                                        triggeredLocomotion = interp1(locomotionTimeVector, triggeredLocomotion, activityTimeVector, 'linear', 'extrap');
                                    end
                                    
                                    % Add to collection
                                    Fig5_Data.TriggeredLocomotion = [Fig5_Data.TriggeredLocomotion; triggeredLocomotion];
                                    Fig5_Data.TriggeredActivity = [Fig5_Data.TriggeredActivity; triggeredActivity];
                                    triggered_event_count = triggered_event_count + 1;
                                end
                            end
                        end
                    end
                end
            end
        end
        
        fprintf('  Added %d triggered events for %s\n', triggered_event_count, condName);
    end
    
    fprintf('  Total triggered events extracted: %d\n', size(Fig5_Data.TriggeredLocomotion, 1));
    fprintf('  Time series length: %d frames (%.1f seconds)\n', totalActivityFrames, totalActivityFrames/activitySamplingRate);
end

function [Fig6_Data] = extractFrameByFrameActivityData(conditions, ActivityData, Behav, Skip, position, Performance, LocomotionFrameRate,)
    % EXTRACTFRAMEBYFRAMEACTIVITYDATA - Extract all locomotion and activity data for frame-by-frame correlation
    
    fprintf('=== Extracting Frame-by-Frame Activity Data for %s ===\n', position);
    
    % Initialize output structure
    Fig6_Data = struct();
    Fig6_Data.AllLocomotionMagnitudes = [];
    Fig6_Data.AllActivityValues = [];
    
    total_frames = 0;
    
    % Process each condition
    for c_idx = 1:length(conditions)
        condName = conditions{c_idx};
        fprintf('Processing frame-by-frame activity data for condition: %s\n', condName);
        
        % Get recordings to skip for this condition
        recordingsToSkip = [];
        if isfield(Skip, condName); recordingsToSkip = Skip.(condName); end
        if ~isempty(recordingsToSkip)
            fprintf('  Skipping recordings %s for %s\n', mat2str(recordingsToSkip), condName);
        end
        
        % Check if condition exists in all required structures
        if ~isfield(ActivityData, condName) || ~isfield(Behav, condName)
            warning('Condition %s not found in one or more required data structures', condName);
            continue;
        end
        
        % Get condition data
        condActivityData = ActivityData.(condName);
        condLocomotionData = Behav.(condName);
        
        frames_this_condition = 0;
        
        % Handle different data structures for different conditions
        if strcmp(condName, 'Expert') || strcmp(condName, 'Beginner')
            % Expert/Beginner: use the same structure as the working extraction function
            for i = 1:min(length(condLocomotionData), length(condActivityData))
                if ismember(i, recordingsToSkip) || isempty(condLocomotionData(i).RunForward); continue; end
                
                % Get position-specific trials if Performance data is available
                activityData = condActivityData(i).all; 
                validTrials = [];
                if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                   length(Performance.(condName)) >= i && ~strcmp(position, 'All')
                    
                    % Get position-specific trials
                    if strcmp(position, 'P1')
                        hitField = 'hitP1'; missField = 'missP1';
                    elseif strcmp(position, 'P3')
                        hitField = 'hitP3'; missField = 'missP3';
                    else
                        hitField = 'hit'; missField = 'miss';
                    end
                    
                    if isfield(Performance.(condName)(i), hitField) && isfield(Performance.(condName)(i), missField)
                        hitTrials = Performance.(condName)(i).(hitField);
                        missTrials = Performance.(condName)(i).(missField);
                        validTrials = [hitTrials, missTrials];
                    else
                        validTrials = 1:min([size(activityData, 3), 150]);
                    end
                else
                    % Use all trials for 'All' position or when Performance data not available
                    validTrials = 1:min([size(activityData, 3), 150]);
                end

                % Process position-specific trials
                for trial = validTrials(1:min(20, length(validTrials)))
                    if trial > size(activityData, 3) || trial > size(condLocomotionData(i).RunForward, 1); continue; end
                    
                    % Get trial locomotion data
                    locomotionTrace = condLocomotionData(i).RunForward(trial,:)' * LocomotionFrameRate;
                    
                    % Get trial activity data (average across neurons for each frame)
                    trialActivity = squeeze(mean(activityData(:, :, trial), 1)); % [frames]
                    
                    % Interpolate locomotion to match activity sampling rate
                    locomotionFrames = length(locomotionTrace);
                    activityFrames = length(trialActivity);
                    
                    if locomotionFrames ~= activityFrames
                        % Check if we have enough points for interpolation
                        if locomotionFrames < 2
                            fprintf('    Warning: Insufficient locomotion frames (%d) for interpolation, skipping trial\n', locomotionFrames);
                            continue;
                        end
                        
                        locomotionTimeVector = linspace(0, 1, locomotionFrames);
                        activityTimeVector = linspace(0, 1, activityFrames);
                        trialLocomotion = interp1(locomotionTimeVector, locomotionTrace, activityTimeVector, 'linear', 'extrap');
                    else
                        trialLocomotion = locomotionTrace;
                    end
                    
                    lenFrames = min(length(trialActivity), length(trialLocomotion));
                    if lenFrames < 10; continue; end % Skip very short trials
                    
                    trialActivity = trialActivity(1:lenFrames);
                    trialLocomotion = trialLocomotion(1:lenFrames);
                    
                    % Add to collection
                    Fig6_Data.AllLocomotionMagnitudes = [Fig6_Data.AllLocomotionMagnitudes; trialLocomotion(:)];
                    Fig6_Data.AllActivityValues = [Fig6_Data.AllActivityValues; trialActivity(:)];
                    frames_this_condition = frames_this_condition + lenFrames;
                end
            end
            
        else
            % Naive/NoSpout: different structure 
            for a = 1:size(condLocomotionData, 2)
                if ismember(a, recordingsToSkip); continue; end
                
                if isfield(condLocomotionData(a), 'Forward_mm') && ...
                   a <= length(condActivityData) && isfield(condActivityData(a), 'all')
                    locomotionTrace = condLocomotionData(a).Forward_mm;
                    activityData = condActivityData(a).all; % [neurons x frames x trials]
                    
                    % Trial segmentation
                    TrialLength = floor(length(locomotionTrace) / 150);
                    if TrialLength > 0
                        TrialMovement = 1:TrialLength:length(locomotionTrace);
                        
                        % Get position-specific trials
                        validTrialSegments = [];
                        if exist('Performance', 'var') && ~isempty(Performance) && isfield(Performance, condName) && ...
                           length(Performance.(condName)) >= a && ~strcmp(position, 'All')
                            
                            if strcmp(position, 'P1')
                                hitField = 'hitP1'; missField = 'missP1';
                            elseif strcmp(position, 'P3')
                                hitField = 'hitP3'; missField = 'missP3';
                            else
                                hitField = 'hit'; missField = 'miss';
                            end
                            
                            if isfield(Performance.(condName)(a), hitField) && isfield(Performance.(condName)(a), missField)
                                hitTrials = Performance.(condName)(a).(hitField);
                                missTrials = Performance.(condName)(a).(missField);
                                validTrialSegments = [hitTrials, missTrials];
                            else
                                validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                            end
                        else
                            validTrialSegments = 1:min([150, length(TrialMovement)-1, size(activityData, 3)]);
                        end
                        
                        % Process trial segments
                        for t = validTrialSegments
                            
                            trial_start = TrialMovement(t);
                            trial_end = TrialMovement(t+1) - 1;
                            trial_locomotion = locomotionTrace(trial_start:trial_end) * TrialLength / 12;
                            
                            % Get trial activity data (average across neurons for each frame)
                            trialActivity = squeeze(mean(activityData(:, :, t), 1)); % [frames]
                            
                            % Interpolate to match sampling rates
                            locomotionFrames = length(trial_locomotion);
                            activityFrames = length(trialActivity);
                            
                            if locomotionFrames ~= activityFrames
                                % Check if we have enough points for interpolation
                                if locomotionFrames < 2
                                    fprintf('    Warning: Insufficient locomotion frames (%d) for interpolation, skipping trial\n', locomotionFrames);
                                    continue;
                                end
                                
                                locomotionTimeVector = linspace(0, 1, locomotionFrames);
                                activityTimeVector = linspace(0, 1, activityFrames);
                                trial_locomotion = interp1(locomotionTimeVector, trial_locomotion, activityTimeVector, 'linear', 'extrap');
                            end
                            
                            lenFrames = min(length(trialActivity), length(trial_locomotion));
                            if lenFrames < 10; continue; end % Skip very short trials
                            
                            trialActivity = trialActivity(1:lenFrames);
                            trial_locomotion = trial_locomotion(1:lenFrames);
                            
                            % Add to collection
                            Fig6_Data.AllLocomotionMagnitudes = [Fig6_Data.AllLocomotionMagnitudes; trial_locomotion(:)];
                            Fig6_Data.AllActivityValues = [Fig6_Data.AllActivityValues; trialActivity(:)];
                            frames_this_condition = frames_this_condition + lenFrames;
                        end
                    end
                end
            end
        end
        
        fprintf('  Added %d frames for %s\n', frames_this_condition, condName);
        total_frames = total_frames + frames_this_condition;
    end
    
    fprintf('  Total frames extracted: %d\n', total_frames);
    fprintf('  Valid data points: %d\n', sum(~isnan(Fig6_Data.AllLocomotionMagnitudes) & ~isnan(Fig6_Data.AllActivityValues)));
end

function validateLocomotionActivityDataConsistency(Fig1_Data, Fig3_Data, Fig4_Data)
    % VALIDATELOCOMOTIONACTIVITYDATACONSISTENCY - Validate consistency across extractions
    
    fprintf('\n=== LOCOMOTION ACTIVITY DATA CONSISTENCY VALIDATION ===\n');
    
    % Check consistency of array lengths
    nPrePost = length(Fig1_Data.PreLocomotionActivity);
    nLabels = length(Fig1_Data.AllConditionLabels);
    nRatios = length(Fig3_Data.ActivityRatio);
    nChanges = length(Fig4_Data.ActivityChange);
    
    fprintf('Data array lengths:\n');
    fprintf('  Pre/Post activity: %d\n', nPrePost);
    fprintf('  Condition labels: %d\n', nLabels);
    fprintf('  Activity ratios: %d\n', nRatios);
    fprintf('  Activity changes: %d\n', nChanges);
    
    % Check consistency
    consistency_check = true;
    
    if nPrePost ~= nLabels
        fprintf('ERROR: Pre/Post activity and condition labels length mismatch!\n');
        consistency_check = false;
    end
    
    if nPrePost ~= nRatios
        fprintf('ERROR: Pre/Post activity and ratios length mismatch!\n');
        consistency_check = false;
    end
    
    if nPrePost ~= nChanges
        fprintf('ERROR: Pre/Post activity and changes length mismatch!\n');
        consistency_check = false;
    end
    
    if consistency_check
        fprintf('✓ All locomotion activity data extractions are CONSISTENT!\n');
    else
        fprintf('✗ Locomotion activity data INCONSISTENCIES detected - please review\n');
    end
    
    fprintf('=== END VALIDATION ===\n\n');
end 